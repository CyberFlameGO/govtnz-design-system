const fs = require('fs');
const path = require('path');
const Marked = require('marked');
const glob = require('glob-promise');
const puppeteer = require('puppeteer');
const mkdirp = require('mkdirp');
const webpack = require('webpack');
const { startCase, uniq, clamp } = require('lodash');
const {
  escapeRegex,
  importGenerator,
  importSourceGenerator,
  getDsPath,
  pathExists,
  insertTemplate,
  writeFile,
  removeMatch,
  pageContentComponentSignature,
} = require('./utils');
const {
  jsxToUsageCode,
  makeUsage,
  ALL_FORMATS,
} = require('@springload/metatemplate');
const jsxtojson = require('jsx2json');

const autogeneratedFileSignature = '// @autogenerated\n';

const generatePage = async (
  sectionId,
  pageId,
  metaTemplateInputsById,
  templateFormatsById
) => {
  // Note that although this doesn't necessarily corrospond to a
  // component from the DS because it might be a 'Grid' or 'Heading'
  // documentation page that groups together several components into
  // one page of documentation.

  let docPath;
  if (sectionId === 'ds') {
    docPath = await getDsPath(`docs/${pageId}.md`);
  } else {
    const sectionPath = path.join(__dirname, '..', `src/docs/${sectionId}`);
    docPath = path.join(sectionPath, `${pageId}.md`);
    const sectionDocPathExists = await pathExists(docPath);
    if (!sectionDocPathExists) {
      console.info(`Can't find ${docPath}`);
    }
    if (sectionId === 'components' && !sectionDocPathExists) {
      const dsDocPath = `docs/${pageId}.md`;
      const componentDocPath = await getDsPath(dsDocPath);
      if (!(await pathExists(componentDocPath))) {
        console.log('\n\n');
        console.trace();
        console.log('\n\n');
        throw new Error(
          `In "${sectionId}" with "${pageId}" can't find doc at "${docPath}" or DS "${dsDocPath}".`
        );
      }
      docPath = componentDocPath;
    }
  }

  const filesToNotDelete = [];
  const rootDir = path.resolve(__dirname, '../..');

  let md = '';
  try {
    md = await fs.promises.readFile(docPath, { encoding: 'utf-8' });
    console.info(
      `Found custom markdown file for ${pageId} at ${docPath.substr(
        rootDir.length + 1
      )}`
    );
  } catch (e) {
    const templateIdFriendlyNames = {
      h1: 'H1',
      h2: 'H2',
      h3: 'H3',
      h4: 'H4',
      h5: 'H5',
      h6: 'H6',
    };

    console.info(
      `Unable to find custom markdown file for ${pageId} at ${docPath.substr(
        rootDir.length + 1
      )} so using default.`
    );
    // use default page
    md = `# ${startCase(templateIdFriendlyNames[pageId] || pageId)}\n`;
  }

  let html = Marked(md, {
    xhtml: true, // because we want valid JSX
  });
  // html = html.replace(/<\/P><\/p>/g, '</P>'); // Marked decides to close tags that weren't ever open. This is a brittle fix but it works...currently.

  let fullImports = [];
  let importsByName = [];

  html = html
    .replace(
      /<h([1-6]).*?>code:([a-zA-Z0-9]+)<\/h[1-6]>/gi,
      (match, headingLevel, componentId) => {
        // We support a subformat within markdown of "code:ComponentName"
        // to display an example and code for that component.
        // The rendered HTML from that component includes headings, so
        // to stay within the correct heading level structurally we
        // allow writing markdown as
        // "## code:ComponentName" to make heading levels start at H2, or
        // "### code:ComponentName" to make heading levels start at H3 etc.
        const trimmedComponentId = componentId.trim();
        importsByName.push(trimmedComponentId);
        const sourceImport = importSourceGenerator(trimmedComponentId);
        fullImports.push(sourceImport);
        return ComponentCode(
          trimmedComponentId,
          templateFormatsById,
          parseInt(headingLevel, 10)
        );
      }
    )
    .replace(/code:([a-zA-Z0-9]+)/gi, (match, componentId) => {
      // Any remaining "code:componentName" that weren't in headings
      // are converted with a default heading level
      const trimmedComponentId = componentId.trim();
      importsByName.push(trimmedComponentId);
      const sourceImport = importSourceGenerator(trimmedComponentId);
      fullImports.push(sourceImport);
      return ComponentCode(trimmedComponentId, templateFormatsById);
    })
    .replace(/<h([1-6]).*?<\/h[1-6]>/, (match, level) => {
      const levelToStyleSize = {
        '1': 'xlarge',
        '2': 'large',
        '3': 'medium',
        '4': 'small',
        '5': 'xsmall',
        '6': 'xxsmall',
      };
      importsByName.push(`H${level}`);
      return (
        `<H${level} styleSize="${levelToStyleSize[level]}"` +
        match.substring(3, match.length - 5) +
        `</H${level}>`
      );
    })
    .replace(/<ul>/g, () => {
      // Convert markdown <ul> to <Ul> DS Components
      return '<Ul bulleted>';
    })
    .replace(/<\/ul>/g, () => {
      // Convert markdown <ul> to <Ul> DS Components
      return '</Ul>';
    })
    .replace(/<li>/g, () => {
      // Convert markdown <ul> to <Ul> DS Components
      return '<Li>';
    })
    .replace(/<\/li>/g, () => {
      // Convert markdown <ul> to <Ul> DS Components
      return '</Li>';
    });

  const exampleContainersRegex = /<ExampleContainer>([\s\S]*?)<\/ExampleContainer>/g;
  const exampleHeadingRegex = /<ExampleHeading>([\s\S]*?)<\/ExampleHeading>/g;
  const exampleRegex = /<Example( [\s\S]*?>|>)([\s\S]*?)<\/Example>/g;

  const matches = html.match(exampleContainersRegex);

  if (matches) {
    const exampleRelativePaths = new Array(matches.length);
    const exampleTitles = new Array(matches.length);
    const exampleHeights = new Array(matches.length);
    const exampleIds = new Array(matches.length);

    const exampleCodes = await Promise.all(
      matches.map(async (match, counter) => {
        const fullExamples = match.match(exampleRegex);
        const headings = match.match(exampleHeadingRegex);
        if (!fullExamples) {
          throw Error(
            `Unexpected lack of <Example> within an <ExampleContainer>. Code was: ${match}`
          );
        }
        if (fullExamples.length !== 1) {
          throw Error(
            `Unexpected number of examples within an example container of fullExamples.length = ${
              fullExamples.length
            }`
          );
        }

        const fullExample = fullExamples[0];

        const exampleAsJS = jsxtojson(fullExample);

        let heading = exampleAsJS.props && exampleAsJS.props.title;
        if (!heading) {
          heading =
            (headings &&
              headings[0] &&
              headings[0].replace(/<[\s\S]*?>/gi, '')) || // remove all tags
            `Example ${counter + 1}`;
        }
        if (!heading.match(/example/i)) {
          heading = `${heading} (${pageId} example)`;
        }

        const exampleRelativePath = `${pageId}__example${counter}`;
        exampleRelativePaths[
          counter
        ] = `/${sectionId}/${exampleRelativePath}.html`;
        exampleTitles[counter] = heading;
        exampleIds[counter] = `iframe_${sectionId}${pageId}${counter}`.replace(
          /[^a-zA-Z0-9_]/g,
          ''
        );
        const exampleSrcPath = await writeExamplePage(
          `${sectionId}/${exampleRelativePath}`,
          addOnStateChanged(fullExample),
          exampleTitles[counter],
          exampleIds[counter],
          `./${pageId}`
        );

        const exampleHeight = await getExampleHeight(exampleSrcPath);

        exampleHeights[counter] = exampleHeight;

        filesToNotDelete.push(
          path.resolve(__dirname, '../src', exampleSrcPath)
        );

        const example = fullExample
          .replace(/<ExampleSection>/g, '')
          .replace(/<\/ExampleSection>/g, '')
          .replace(/<ExampleHeading>/g, '')
          .replace(/<\/ExampleHeading>/g, '')
          .replace(/<Example( [\s\S]*?>|>)/g, '')
          .replace(/<\/Example>/g, '');

        try {
          const code = await jsxToUsageCode(example);
          const files = await makeUsage(code, metaTemplateInputsById, [
            ALL_FORMATS,
          ]);
          return files;
        } catch (e) {
          console.log(`Problem with ${sectionId}/${pageId}: ${example}`);
          console.log(e);
          throw e;
        }
      })
    );

    const importName = `${sectionId}__${pageId}`;
    const srcCodePath = path.join('commons', 'examples', importName);
    const examplesPath = path.resolve(
      __dirname,
      '..',
      'src',
      srcCodePath + '.ts'
    );
    let examplesFileCode = `${autogeneratedFileSignature}\n\nexport default ${JSON.stringify(
      exampleCodes,
      null,
      2
    )}`;

    await writeFile(examplesPath, examplesFileCode);
    filesToNotDelete.push(examplesPath);

    fullImports.push(`import ${importName} from '../../${srcCodePath}';`);

    let counter = 0;
    html = html.replace(/<Example( [\s\S]*?>|>)[\s\S]*?<\/Example>/g, match => {
      const isCodeOnly = match.includes('codeOnly');
      counter++;
      if (isCodeOnly) {
        return ''; // nothing to render
      }
      return `<Example code={${importName}[${counter - 1}]} iframeProps={{
        id:"${exampleIds[counter - 1]}",
        className: "example__iframe",
        src:"${exampleRelativePaths[counter - 1]}",
        title:"${exampleTitles[counter - 1]}",
        height: ${exampleHeights[counter - 1]}
      }}></Example>`;
    });
  }

  const tagNames = html.match(/<([a-zA-Z0-9]+)/g);

  // because we import these in the template already
  const ComponentIdsThatDontNeedImports = [
    'Example',
    'ExampleSection',
    'ExampleHeading',
    'ExampleContainer',
    'ComponentCode',
  ];

  const reactComponentNames =
    tagNames &&
    tagNames
      .map(tag => tag.replace(/^</gi, ''))
      .filter(tag => {
        // All React components in our DS have a capital letter in their name
        return !!tag.match(/[A-Z]/);
      })
      .filter(tag => ComponentIdsThatDontNeedImports.indexOf(tag) === -1);

  html = addOnStateChanged(html);

  const uniqueReactComponentNames = uniq(reactComponentNames);
  let imports = await Promise.all(
    [...uniqueReactComponentNames, ...importsByName]
      .filter(name => ComponentIdsThatDontNeedImports.indexOf(name) === -1)
      .map(name => {
        // Dev note: importGenerator returns a promise so we're intentionally
        // not awaiting it so that we can pass it to Promise.all()
        const code = importGenerator(name);
        if (!code) {
          throw Error(`Unable to find imports for "${name}" from\n${md}`);
        }
        return code;
      })
  );
  imports = uniq([...imports, ...fullImports]);

  const LINEBREAK = '[[LINEBREAK]]';
  html = html
    .replace(/\n/gi, LINEBREAK)
    .replace(/<pre>/gi, '<pre className="language-code">')
    .replace(/<a ([^>]*?)>.*?<\/a>/gi, (match, aAttributes) => {
      // Convert appropriate links to <Link to> to use fast and JS-based
      // lazy-loading rather than <a href> which forces a full page reload
      // between loads.

      // If the hyperlink is offsite then we can't use <Link to>
      // so we want to render a regular <a href>
      if (
        aAttributes.indexOf('https://') !== -1 ||
        aAttributes.indexOf('http://') !== -1
      ) {
        return match;
      }
      // Otherwise use <Link to>
      let link = match
        .replace(/^<a/gi, '<Link')
        .replace(/<\/a>$/gi, '</Link>')
        .replace('href=', 'to=');

      if (link.includes('/components/')) {
        link = link.replace(/to="(.*?)"/, (match, uri) => {
          if (!uri.endsWith('/')) {
            return `to="${uri}/"`;
          }
          return match;
        });
      }

      return link;
    });

  function ComponentCode(componentId, templateFormatsById, headingLevel) {
    const templateFormats = templateFormatsById[componentId];
    if (!templateFormats || !templateFormats.html) {
      console.info(`Note: No HTML found for component "${componentId}".`);
      return ' ';
    }
    return `<ComponentCode Component={${componentId}} templateFormats={${componentId}__templateFormats} startAtHeadingLevel={${headingLevel}}/>`;
  }

  let componentString = `<React.Fragment>${html}</React.Fragment>`
    .replace(new RegExp(escapeRegex(LINEBREAK), 'g'), '\n')
    .replace(/class=/gi, 'className=') // convert HTML to React JSX with class -> className. FIXME: Use a real HTML parser
    .replace(/for=/gi, 'htmlFor='); // convert HTML to React JSX with for -> htmlFor. FIXME: Use a real HTML parser

  return [imports, componentString, filesToNotDelete];
};

const writeExamplePage = async (
  exampleRelativePagePath,
  exampleData,
  title,
  id,
  parentUrl
) => {
  // This writes an example HTML file so that we can iframe it.
  //
  // Back story for why we're doing this:
  //
  // The Design System site has a very specific and Niche Requirement[tm]:
  //
  //   We want to have examples that use the DS components without
  //   theming, but we also want to use DS components with theming.
  //
  // Unfortunately Gatsby has an optimisation which means it may
  // preload CSS from other pages, even if those pages couldn't possibly
  // be browsed to. It's not Gatsby's fault that it can't detect
  // whether a page is potentially navigable from another page because
  // this is a very hard problem, but we're stuck with their naive
  // optimisation to preload CSS just in case we'd browse to it.
  //
  // Normally this problem is solved in Gatsby by using distinct CSS
  // classes for different components,
  // See https://github.com/gatsbyjs/gatsby/issues/3446
  // But --to repeat-- Gatsby can't have per-page CSS... there's no way of
  // having different CSS in an iframe vs another page because Gatsby
  // doesn't know about iframes of whether it's possible to reach one page
  // from another -- so Gatsby can potentially just add all CSS from any
  // page from the entire site onto other pages. In most cases this is an
  // optimisation, but in our case it conflicts with our Niche Requirement[tm]
  //
  // So what can we do to solve this?
  //
  // Well it's very complicated, but it seems to be necessary.
  //
  // We build pages for every example and put that under the "/static/"
  // directory so that it's copied into "/public" as-is, and this involves
  // building every example which might involve multiple components etc.,
  // that means every example needs its own WebPack config that can resolve
  // imports and stuff like that.
  //
  // So that's what this function is doing. It's working around Gatsby's inability
  // to have distinct pages that are COMPLETELY separate from others with the same
  // css classes...
  //
  // ...and it's not even a bug of Gatsby, we just have Niche Requirements[tm] that
  // Gatsby doesn't support.
  //
  // So now you know. Please don't hate me.

  const tsxTemplatePath = path.resolve(
    __dirname,
    '..',
    'src/commons/templates/example-iframe.tsx'
  );

  // because we import these in the template already
  const ComponentIdsThatDontNeedImports = [
    'Example',
    'ExampleSection',
    'ComponentCode',
    'ExampleContainer',
  ];

  const tsxTemplate = await fs.promises.readFile(tsxTemplatePath, {
    encoding: 'utf-8',
  });
  const tagNames = exampleData.match(/<([a-zA-Z0-9]+)/g);
  const reactComponentNames =
    tagNames &&
    tagNames
      .map(tag => tag.replace(/^</gi, ''))
      .filter(tag => {
        // All React components in our DS have a capital letter in their name
        return !!tag.match(/[A-Z]/);
      })
      .filter(tag => ComponentIdsThatDontNeedImports.indexOf(tag) === -1);

  const scriptImports = uniq(reactComponentNames).map(
    reactComponentName =>
      `import ${reactComponentName} from '@govtnz/ds/build/react-ts/${reactComponentName}.tsx';`
  );

  const WARNING = `${autogeneratedFileSignature}\n// WARNING THIS FILE IS AUTOGENERATED! DO NOT EDIT!\n\n`;
  const page =
    WARNING +
    insertTemplate(
      tsxTemplate,
      {
        id,
        title,
        parentUrl,
      },
      scriptImports.join('')
    ).replace(
      pageContentComponentSignature,
      `var PageContent = (props) => (${exampleData});`
    );

  const tsxRelativePath = `${exampleRelativePagePath}.tsx`;
  const tsxFullPath = path.resolve(__dirname, '..', 'static', tsxRelativePath);
  const tsxFullDirectory = tsxFullPath.substring(
    0,
    tsxFullPath.length - path.basename(tsxFullPath).length
  );
  mkdirp.sync(tsxFullDirectory);
  await fs.promises.writeFile(tsxFullPath, page, { encoding: 'utf-8' });
  const jsRelativePath = `${exampleRelativePagePath}.js`;
  const jsFullPath = path.resolve(__dirname, '..', 'static', jsRelativePath);
  const jsFullDirectory = jsFullPath.substring(
    0,
    jsFullPath.length - path.basename(jsFullPath).length
  );
  const jsFilename = path.basename(jsFullPath);

  const webpackConfig = {
    entry: tsxFullPath,
    output: { path: jsFullDirectory, filename: jsFilename },
    mode: 'production',
    module: {
      rules: [
        {
          test: /\.(js|ts)x?$/,
          exclude: /(node_modules)/,
          use: [
            {
              loader: 'babel-loader',
              options: {
                presets: [
                  '@babel/preset-env',
                  '@babel/preset-react',
                  '@babel/preset-typescript',
                ],
              },
            },
          ],
        },
      ],
    },
    externals: {
      // Use external version of React so that every example
      // doesn't bundle its own copy
      react: 'React',
      'react-dom': 'ReactDOM',
    },
  };

  await new Promise((resolve, reject) => {
    webpack(webpackConfig, (err, stats) => {
      if (err) {
        reject(err);
        console.error(err);
        throw Error(err);
      } else {
        resolve(stats);
      }
    });
  });

  const htmlTemplatePath = path.resolve(
    __dirname,
    '..',
    'src/commons/templates/example-iframe.html'
  );

  const htmlTemplate = await fs.promises.readFile(htmlTemplatePath, {
    encoding: 'utf-8',
  });

  const scriptUrl = jsFullPath.substring(
    path.resolve(__dirname, '..', 'static').length
  );

  const serverExampleHTML = '...'; // ReactDOMServer.renderToStaticMarkup();

  const cssImports = uniq(reactComponentNames)
    .map(
      cssFileName => `<link rel="stylesheet" href="../css/${cssFileName}.css">`
    )
    .join('');

  const cssDirectoryPath = path.resolve(__dirname, '..', 'static', 'css');
  mkdirp.sync(cssDirectoryPath);
  await Promise.all(
    uniq(reactComponentNames).map(cssFileName =>
      fs.promises.copyFile(
        path.resolve(
          __dirname,
          '../..',
          'govtnz-ds/build/css',
          `${cssFileName}.css`
        ),
        path.resolve(__dirname, '..', 'static/css', `${cssFileName}.css`)
      )
    )
  );

  const html = insertTemplate(htmlTemplate, {
    id,
    title,
    parentUrl,
    scriptUrl,
    serverExampleHTML,
  }).replace('@css', cssImports);

  const htmlRelativePath = `${exampleRelativePagePath}.html`;
  const htmlFullPath = path.resolve(
    __dirname,
    '..',
    'static',
    htmlRelativePath
  );

  await fs.promises.writeFile(htmlFullPath, html, { encoding: 'utf-8' });
  return htmlRelativePath;
};

const getExampleHeight = async srcPath => {
  // This function starts up Chromium and measures the
  // height of examples so that the <iframe> can be given
  // a specific height, and this is done to reduce onscreen jank.
  //
  // Note that this involves reading files from /public/
  // which will be the previous build so it won't pick up any
  // recent changes. So the determined height will always be
  // one build behind (N - 1) however this is considered
  // acceptable because:
  //
  //    1) there's JavaScript to resize the iframe anyway, so this
  //       initial value isn't particularly important other than to
  //       minimise jank;
  //    2) the alternative before this was a default size of 100px
  //       in all cases which was considered worse, so this is
  //       considered an improvement.
  //
  //  ...but feel free to somehow build the site, calculate example
  //  heights, and then update sizes in the pages, and then build the
  //  site again with those sizes, if an N-1 size is too out-of-sync
  //  for you.

  let height = 100;
  const npmProjectPath = path.resolve(__dirname, '..');

  const fullFilePath = path.join(npmProjectPath, 'public', srcPath);

  if (!fs.existsSync(fullFilePath)) {
    console.error(
      `Example file doesn't exist at `,
      fullFilePath,
      ' from ',
      srcPath,
      ' This might be expected if this is a new example, and re-running this after a `yarn build` should make this error go away.'
    );
    return height;
  }

  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  const fileUri = `file://${fullFilePath}`;

  try {
    await page.goto(fileUri);
  } catch (e) {
    console.error(
      'Problem calculating height of example at ',
      fileUri,
      ' This might be expected if this is a new example, and re-running this after a `yarn build` should make this error go away.',
      e
    );
  }

  const newHeight = await page.$eval('#root', element => element.offsetHeight);

  if (
    newHeight.toString().length > 0 &&
    newHeight.toString().replace(/[0-9]/gi, '').length === 0 // if it is entirely a number
  ) {
    height = clamp(parseFloat(newHeight.toString()), 50, 10000);
  }

  await browser.close();
  return height;
};

module.exports.generateComponentPages = async (
  templateFormatsById,
  filesToDelete,
  metaTemplateInputsById
) => {
  const codePreviewPath = path.resolve(
    __dirname,
    '..',
    'src/commons/templates/component-sourcecode.tsx'
  );
  const codeTemplate = await fs.promises.readFile(codePreviewPath, {
    encoding: 'utf-8',
  });
  const componentPageTemplatePath = path.resolve(
    __dirname,
    '..',
    'src/commons/templates/component-template.tsx'
  );
  const pageTemplate = await fs.promises.readFile(componentPageTemplatePath, {
    encoding: 'utf-8',
  });
  const sectionId = 'components';

  const keys = Object.keys(templateFormatsById);

  await Promise.all(
    keys
      .filter(name => ComponentIdsThatDontNeedImports.indexOf(name) === -1)
      .map(async templateId => {
        const templateFormats = templateFormatsById[templateId];
        // if (!templateFormats.html) {
        //   console.log(`Component without HTML. Template id = "${templateId}"`)
        //   return
        // }
        let imports = [await importGenerator(templateId)];
        const [
          componentImports,
          generatedComponentPage,
          filesToNotDelete,
        ] = await generatePage(
          sectionId,
          templateId,
          metaTemplateInputsById,
          templateFormatsById
        );
        imports = uniq(imports.concat(componentImports));

        filesToNotDelete.forEach(fileToNotDelete => {
          filesToDelete = removeMatch(filesToDelete, fileToNotDelete);
        });

        const WARNING = `${autogeneratedFileSignature}\n// WARNING THIS FILE IS AUTOGENERATED! DO NOT EDIT!\n\n`;
        const code =
          WARNING +
          insertTemplate(
            codeTemplate,
            {
              id: templateId,
              templateFormats,
              name: startCase(templateId),
            },
            imports.join('')
          );
        const targetCodePath = path.resolve(
          __dirname,
          '..',
          'src/components/sourcecode',
          `${templateId}.ts`
        );
        await writeFile(targetCodePath, code);
        filesToDelete = removeMatch(filesToDelete, targetCodePath);

        const page =
          WARNING +
          insertTemplate(
            pageTemplate,
            {
              id: templateId,
            },
            imports.join('')
          )
            .replace(
              'export default function Page(',
              `export default function ${templateId}__Page(`
            )
            .replace(
              pageContentComponentSignature,
              `const PageContent = (props) => ${generatedComponentPage}`
            );

        const targetPagePath = path.resolve(
          __dirname,
          '..',
          'src/pages/components',
          `${templateId}.tsx`
        );
        await writeFile(targetPagePath, page);
        filesToDelete = removeMatch(filesToDelete, targetPagePath);
      })
  );
  return filesToDelete;
};

module.exports.generateContentPages = async (
  sectionId,
  templateFormatsById,
  filesToDelete,
  metaTemplateInputsById
) => {
  const sectionDocsPath = path.resolve(
    __dirname,
    '..',
    `src/docs/${sectionId}`
  );
  const pageIdPattern = path.join(sectionDocsPath, '**.md');
  const pageIds = (await glob(pageIdPattern)).map(docPath =>
    path.basename(docPath, '.md')
  );

  const pageTemplatePath = path.resolve(
    __dirname,
    '..',
    `src/commons/templates/${sectionId}-template.tsx`
  );
  const pageTemplate = await fs.promises.readFile(pageTemplatePath, {
    encoding: 'utf-8',
  });

  await Promise.all(
    pageIds.map(async pageId => {
      let imports = [];

      const [
        componentImports,
        generatedComponentPage,
        filesToNotDelete,
      ] = await generatePage(
        sectionId,
        pageId,
        metaTemplateInputsById,
        templateFormatsById
      );
      imports = uniq(imports.concat(componentImports));

      filesToNotDelete.forEach(fileToNotDelete => {
        filesToDelete = removeMatch(filesToDelete, fileToNotDelete);
      });

      const WARNING = `${autogeneratedFileSignature}\n// WARNING THIS FILE IS AUTOGENERATED! DO NOT EDIT!\n\n`;

      const page =
        WARNING +
        insertTemplate(
          pageTemplate,
          {
            id: pageId,
          },
          imports.join('')
        )
          .replace(
            'export default function Page(',
            `export default function ${pageId}__Page(`
          )
          .replace(
            pageContentComponentSignature,
            `const PageContent = (props) => ${generatedComponentPage}`
          );

      const targetPagePath = path.resolve(
        __dirname,
        '..',
        `src/pages/${sectionId}`,
        `${pageId}.tsx`
      );
      await writeFile(targetPagePath, page);
      filesToDelete = removeMatch(filesToDelete, targetPagePath);
    })
  );
  return filesToDelete;
};

const addOnStateChanged = html => {
  return html.replace(/<[A-Z][^ >]+/g, match => {
    // React Managed Components (as distinct from
    // unmanaged components) need a way to set a value
    // and have an onChange handler, but we don't want
    // that state inside the component itself so we attach
    // a basic wrapper on all DS components
    //
    // DS components start with a capital letter
    const tagName = match.substring(1, match.length);
    const addon = match + ` {...onChangeGenerator(${tagName})}`;
    return addon;
  });
};

module.exports.generatePage = generatePage;
module.exports.autogeneratedFileSignature = autogeneratedFileSignature;
