const path = require('path');
const fs = require('fs');
const { pick, uniq } = require('lodash');
const acorn = require('acorn');
const acornJSX = require('acorn-jsx');
const mkdirp = require('mkdirp');
const webpack = require('webpack');
const React = require('react');
const ReactDOMServer = require('react-dom/server');
const {
  autogeneratedFileSignature,
  insertTemplate,
  pageContentComponentSignature,
} = require('./utils');

const writeExamplePage = async (
  exampleRelativePagePath,
  exampleData,
  title,
  id,
  parentUrl
) => {
  // This writes an example HTML file so that we can iframe it.
  //
  // Back story for why we're doing this:
  //
  // The Design System site has a very specific and Niche Requirement[tm]:
  //
  //   We want to have examples that use the DS components without
  //   theming, but we also want to use DS components with theming.
  //
  // Unfortunately Gatsby has an optimisation which means it may
  // preload CSS from other pages, even if those pages couldn't possibly
  // be browsed to. It's not Gatsby's fault that it can't detect
  // whether a page is potentially navigable from another page because
  // this is a very hard problem, but we're stuck with their naive
  // optimisation to preload CSS just in case we'd browse to it.
  //
  // Normally this problem is solved in Gatsby by using distinct CSS
  // classes for different components:
  // See https://github.com/gatsbyjs/gatsby/issues/3446
  //
  // But --to repeat-- Gatsby can't have per-page CSS... there's no way of
  // having different CSS in an iframe vs another page because Gatsby
  // doesn't know about iframes of whether it's possible to reach one page
  // from another -- so Gatsby can potentially just add all CSS from any
  // page from the entire site onto other pages. In most cases this is an
  // optimisation, but in our case it conflicts with our Niche Requirement[tm]
  //
  // So what can we do to solve this?
  //
  // Well it's very complicated, but it seems to be necessary.
  //
  // We build pages for every example and put that under the "/static/"
  // directory so that it's copied into "/public" as-is, and this involves
  // building every example which might involve multiple components etc.,
  // that means every example needs its own WebPack config that can resolve
  // imports and stuff like that.
  //
  // So that's what this function is doing. It's working around Gatsby's inability
  // to have distinct pages that are COMPLETELY separate from others with the same
  // css classes...
  //
  // ...and it's not even a bug of Gatsby, we just have Niche Requirements[tm] that
  // Gatsby doesn't support.
  //
  // So now you know.

  const tsxTemplatePath = path.resolve(
    __dirname,
    '..',
    'src/commons/templates/example-iframe.tsx'
  );

  // because we have these in the template already
  const ComponentIdsThatDontNeedImports = [
    'Example',
    'ExampleSection',
    'ComponentCode',
    'ExampleContainer',
  ];

  const tsxTemplate = await fs.promises.readFile(tsxTemplatePath, {
    encoding: 'utf-8',
  });
  const tagNames = exampleData.match(/<([a-zA-Z0-9]+)/g);
  const reactComponentNames =
    tagNames &&
    tagNames
      .map(tag => tag.replace(/^</gi, ''))
      .filter(tag => {
        // All React components in our DS have a capital letter in their name
        return !!tag.match(/[A-Z]/);
      })
      .filter(tag => ComponentIdsThatDontNeedImports.indexOf(tag) === -1);

  const scriptImports = uniq(reactComponentNames).map(
    reactComponentName =>
      `import ${reactComponentName} from '@govtnz/ds/build/react-ts/${reactComponentName}.tsx';`
  );

  const example = await addOnStateChanged(exampleData);

  const WARNING = `${autogeneratedFileSignature}\n// WARNING THIS FILE IS AUTOGENERATED! DO NOT EDIT!\n\n`;
  const page =
    WARNING +
    insertTemplate(
      tsxTemplate,
      {
        id,
        title,
        parentUrl,
      },
      scriptImports.join('')
    ).replace(
      pageContentComponentSignature,
      `var PageContent = (props) => (${example});`
    );

  const tsxRelativePath = `${exampleRelativePagePath}.tsx`;
  const tsxFullPath = path.resolve(__dirname, '..', 'static', tsxRelativePath);
  const tsxFullDirectory = tsxFullPath.substring(
    0,
    tsxFullPath.length - path.basename(tsxFullPath).length
  );
  mkdirp.sync(tsxFullDirectory);

  const webRenderSuffix = `
      const onChangeGenerator = (props) => {
        // See onChangeGenerator insertion docs.
        // We can't know if a component takes props
        // of 'value' and 'onChange' so we insert some
        // and if they're not used that's ok.
        // The reason why we have 3 is because that's the
        // most number of inputs in a DS components, and it's 
        // simpler to just make 3.
  
        const [value, setValue] = useState(props && props.value);
        const [value2, setValue2] = useState(props && props.value2);
        const [value3, setValue3] = useState(props && props.value3);
      
        return {
          value,
          value2,
          value3,
          onChange: e => setValue(e.target.value),
          onChange2: e => setValue2(e.target.value),
          onChange3: e => setValue3(e.target.value),
        };
      };
    
      document.addEventListener('DOMContentLoaded', () => {
        const selector = '#root';
        const root = document.querySelector(selector);
        if (!root) {
          console.error("Couldn't find app mount point ", selector);
          return;
        }
        ReactDOM.hydrate(<PageContent />, root, window.afterRender);
      });
      `;

  await fs.promises.writeFile(tsxFullPath, page + webRenderSuffix, {
    encoding: 'utf-8',
  });

  const jsRelativePath = `${exampleRelativePagePath}.js`;
  const jsFullPath = path.resolve(__dirname, '..', 'static', jsRelativePath);
  const jsFullDirectory = jsFullPath.substring(
    0,
    jsFullPath.length - path.basename(jsFullPath).length
  );
  const jsFilename = path.basename(jsFullPath);

  const babelConfig = {
    presets: [
      '@babel/preset-env',
      '@babel/preset-react',
      '@babel/preset-typescript',
    ],
  };

  const webpackConfig = {
    entry: tsxFullPath,
    output: { path: jsFullDirectory, filename: jsFilename },
    mode: 'production',
    module: {
      rules: [
        {
          test: /\.(js|ts)x?$/,
          exclude: /(node_modules)/,
          use: [
            {
              loader: 'babel-loader',
              options: babelConfig,
            },
          ],
        },
      ],
    },
    externals: {
      // Use external version of React so that every bundle
      // doesn't include it's own copy because that would be
      // very big (a copy of React with every Example)
      react: 'React',
      'react-dom': 'ReactDOM',
    },
  };

  await new Promise((resolve, reject) => {
    webpack(webpackConfig, (err, stats) => {
      if (err) {
        reject(err);
        console.error(err);
        throw Error(err);
      } else {
        resolve(stats);
      }
    });
  });

  const htmlTemplatePath = path.resolve(
    __dirname,
    '..',
    'src/commons/templates/example-iframe.html'
  );

  const htmlTemplate = await fs.promises.readFile(htmlTemplatePath, {
    encoding: 'utf-8',
  });

  const scriptUrl = `./${path.basename(jsFullPath)}`;

  const cssImports = uniq(reactComponentNames)
    .map(
      cssFileName => `<link rel="stylesheet" href="../css/${cssFileName}.css">`
    )
    .join('');

  const cssDirectoryPath = path.resolve(__dirname, '..', 'static', 'css');
  mkdirp.sync(cssDirectoryPath);
  await Promise.all(
    uniq(reactComponentNames).map(cssFileName =>
      fs.promises.copyFile(
        path.resolve(
          __dirname,
          '../..',
          'govtnz-ds/build/css',
          `${cssFileName}.css`
        ),
        path.resolve(__dirname, '..', 'static/css', `${cssFileName}.css`)
      )
    )
  );

  const serverRender = `
      const onChangeGenerator = () => ({});
      ${page};
      export default PageContent;
  `;

  const tmpDir = path.resolve(__dirname, '..', '.tmp');
  const tmpFile = path.basename(tsxFullPath);
  await mkdirp(tmpDir);
  const tmpPath = path.join(tmpDir, tmpFile);
  const tmpTargetFile = tmpFile + '.js';
  await fs.promises.writeFile(tmpPath, serverRender, {
    encoding: 'utf-8',
  });

  const webpackForServerConfig = {
    entry: tmpPath,
    output: { path: tmpDir, filename: tmpTargetFile, libraryTarget: 'umd' },
    mode: 'development',
    target: 'node',
    module: {
      rules: [
        {
          test: /\.(js|ts)x?$/,
          exclude: /(node_modules)/,
          use: [
            {
              loader: 'babel-loader',
              options: {
                ...babelConfig,
              },
            },
          ],
        },
      ],
    },
  };

  await new Promise((resolve, reject) => {
    webpack(webpackForServerConfig, (err, stats) => {
      if (err) {
        reject(err);
        console.error(err);
        throw Error(err);
      } else {
        resolve(stats);
      }
    });
  });

  const requirePath = path.join(tmpDir, tmpTargetFile);

  const thisExample = require(requirePath);

  const serverExampleHTML = ReactDOMServer.renderToString(
    React.createElement(thisExample.default)
  );

  const html = insertTemplate(htmlTemplate, {
    id,
    title,
    parentUrl,
    scriptUrl,
    serverExampleHTML,
  }).replace('@css', cssImports);

  const htmlRelativePath = `${exampleRelativePagePath}.html`;
  const htmlFullPath = path.resolve(
    __dirname,
    '..',
    'static',
    htmlRelativePath
  );

  await fs.promises.writeFile(htmlFullPath, html, { encoding: 'utf-8' });
  return htmlRelativePath;
};

const addOnStateChanged = async html => {
  // React Managed Components (as distinct from
  // unmanaged components) need a way to set a value
  // and have an onChange handler, but we don't want
  // that state inside the component itself (because
  // who knows if most people would use local component
  // state, or Redux, etc.), so we attach a basic wrapper
  // on all DS components
  //
  // React components have a capital letter in their nodeName
  // https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized
  //
  // so we attach a state manager to ALL react components
  // because if they don't use the props then it's harmless
  // and inspecting components would be more complicated

  wrappedHTML = `<>${html}</>`;
  const ast = acorn.Parser.extend(acornJSX()).parse(wrappedHTML);

  const walk = node => {
    let newHTML = '';

    switch (node.type) {
      case 'JSXElement': {
        const elementName = node.openingElement.name.name;
        newHTML += `<${elementName}`;
        const attrObj = {};
        if (node.openingElement.attributes) {
          newHTML += node.openingElement.attributes
            .map(attr => {
              let attrString = ` ${attr.name.name}`;
              let attrValue;
              if (attr.value && attr.value.type) {
                attrString += '=';
                switch (attr.value && attr.value.type) {
                  case 'Literal': {
                    attrString += attr.value.raw;
                    attrValue = attr.value.value;
                    break;
                  }
                  case 'JSXExpressionContainer': {
                    attrString += wrappedHTML
                      .substring(attr.start, attr.end)
                      .substring(attr.name.name.length + 1);

                    attrValue = wrappedHTML
                      .substring(attr.start, attr.end)
                      .substring(attr.name.name.length + 1)
                      .trim()
                      .replace(/^{/, '')
                      .replace(/}$/, '');
                    break;
                  }
                  default: {
                    console.log({ type: attr.value.type });
                    process.exit();
                    break;
                  }
                }
              } else {
                attrValue = true;
              }
              attrObj[attr.name.name] = attrValue;
              return attrString;
            })
            .join('');
        }
        if (elementName.match(/[A-Z]/)) {
          // if it's a React element and not an HTML element
          // then we will need to attach a state manager
          newHTML += ` {...onChangeGenerator(${JSON.stringify(
            pick(attrObj, 'value', 'value2', 'value3') // provide default values to useState()
          )})}`;
        }
        newHTML += '>';
        newHTML += node.children && node.children.map(walk).join('');
        newHTML += `</${elementName}>`;
        break;
      }
      case 'JSXText': {
        newHTML += node.raw;
        break;
      }
      default: {
        console.log('Unknown JSX node type', node.type);
        console.log(JSON.stringify(node));
        process.exit();
        break;
      }
    }

    return newHTML;
  };

  const newHTML = ast.body[0].expression.children.map(walk).join('');

  return newHTML;
};

module.exports.addOnStateChanged = addOnStateChanged;
module.exports.writeExamplePage = writeExamplePage;
